import serial
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import os
import shutil
from scipy.stats import zscore 

def sensor_calibrator():
    # Initial Reset
    file_name = 'PTCal_test0'
    folder_name = 'PTCal_testfold'
    test_device = 'PT '
    data_length = 7
    data_point_num = 10
    serial_port_name = 'COM14'  # on Windows would be COM#. Open device manager and check ports.

    # Check if data file exists
    data_file_exist = os.path.exists(f'{file_name}.xls')
    if data_file_exist:
        prev_table = pd.read_excel(f'{file_name}.xls')
        prev_array = prev_table.to_numpy()[2:, :]
        col_length = prev_array.shape[1]
        if data_length != col_length - 1:
            raise Exception("The file you are reading from has a different number of sensor being logged, change the name of the file or delete the original file")
    
    # Set up dynamic table columns
    data_labels = [f'{test_device}{i}' for i in range(1, data_length + 1)]
    data_labels.append(f'{test_device}Readings')

    # Set up serial object
    s = serial.Serial(serial_port_name, 115200)

    # Open serial port and read data
    raw_data = []
    i = 1
    try:
        while True:
            str_data = s.readline().decode().strip().split()
            print("got it")
    
            if len(str_data) != data_length:
                continue

            try:
                m = float(str_data[0])
            except ValueError:
                continue

            #for i in range (len(str_data)):
            raw_data.append([float(x) for x in str_data[1:]])

            if len(raw_data) > data_point_num:
                
                raw_data.pop(0)
           
    except KeyboardInterrupt:
        # User interrupted the process, now clean up
        print(raw_data)
        clean_me_up(raw_data, file_name, folder_name, data_labels, data_length, s)

def clean_me_up(raw_data, file_name, folder_name, data_labels, data_length, s):

    reading = float(input("What is the pressure gauge reading? (Numbers only) \n"))

    if not os.path.exists(folder_name):
        os.makedirs(folder_name)
        print("test data folder created\n")
    else:
        print("folder already exists\n")

    # calculate mean values
    data_array = np.array(raw_data)
    mean_array = np.mean(data_array, axis=0)
    # mean_array: [-1.00000e+00 -4.25500e+02  1.84100e+02  1.23733e+04 -1.00000e+00 -1.00000e+00]

    mean_vals = []

    process_array = []

    [mean_vals.append([i, reading]) for i in mean_array]
    # [[-1.0, 10.0], [-425.5, 10.0], [184.1, 10.0], [12373.3, 10.0], [-1.0, 10.0], [-1.0, 10.0]]

    process_array.append(mean_vals)
    # [[[-1.0, 10.0], [-425.5, 10.0], [184.1, 10.0], [12373.3, 10.0], [-1.0, 10.0], [-1.0, 10.0]]]


    a = []
    b = []
    endsol = []
    if len(process_array)>1:
        for j in range(data_length):
            X = process_array[j]
            Y = process_array[-1]
            coefficients = np.polyfit([X], [Y], 1)
            a.append(coefficients[0])
            b.append(coefficients[1])
            endsol.append(coefficients)

    #     final_array = [a + [np.nan], b + [np.nan], list(process_array)]
    #     test_data_table = pd.DataFrame(final_array, columns=data_labels)

    #     file_string = f"{file_name}.xls"

    #     if os.path.exists(f"{file_name}.xls"):
    #         test_data_table.to_excel(file_string, index=False)
    #         shutil.move(file_string, folder_name)
    #     else:
    #         test_data_table.to_excel(file_string, index=False)
    #         shutil.move(file_string, folder_name)

    #     data_processing_graphing(process_array, endsol)
    # print(f'saving test data as {file_name}.xls\n')
    # s.close()

def data_processing_graphing(array, solution):
    fig, axs = plt.subplots(len(array) - 1, 1, figsize=(10, 10))
    for k in range(len(array) - 1):
        axs[k].plot(array[k], array[-1], 'o')
        title_string = f"Sensor {k + 1}"
        axs[k].set_title(title_string)
        x = np.linspace(min(array[k]), max(array[k]), 100)
        y = solution[k][0] * x + solution[k][1]
        axs[k].plot(x, y)
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    sensor_calibrator()
